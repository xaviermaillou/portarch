{"ast":null,"code":"/** @module promise-nodeify\n * @copyright Copyright 2016-2018 Kevin Locke <kevin@kevinlocke.name>\n * @license MIT\n */\n'use strict';\n/** Function which will run with a clear stack as soon as possible.\n * @private\n */\n\nconst later = typeof process !== 'undefined' && typeof process.nextTick === 'function' ? process.nextTick : typeof setImmediate === 'function' ? setImmediate : setTimeout;\n/** Invokes callback and ensures any exceptions thrown are uncaught.\n * @private\n */\n\nfunction doCallback(callback, reason, value) {\n  // Note:  Could delay callback call until later, as When.js does, but this\n  // loses the stack (particularly for bluebird long traces) and causes\n  // unnecessary delay in the non-exception (common) case.\n  try {\n    // Match argument length to resolve/reject in case callback cares.\n    // Note:  bluebird has argument length 1 if value === undefined due to\n    // https://github.com/petkaantonov/bluebird/issues/170\n    // If you are reading this and want similar behavior, I'll consider it.\n    if (reason) {\n      callback(reason);\n    } else {\n      callback(null, value);\n    }\n  } catch (err) {\n    later(() => {\n      throw err;\n    });\n  }\n}\n/** Calls a node-style callback when a Promise is resolved or rejected.\n *\n * This function provides the behavior of\n * {@link https://github.com/then/nodeify then <code>nodeify</code>},\n * {@link\n * https://github.com/cujojs/when/blob/master/docs/api.md#nodebindcallback\n * when.js <code>node.bindCallback</code>},\n * or {@link http://bluebirdjs.com/docs/api/ascallback.html bluebird\n * <code>Promise.prototype.nodeify</code> (now\n * <code>Promise.prototype.asCallback</code>)} (without options).\n *\n * @ template ValueType\n * @param {!Promise<ValueType>} promise Promise to monitor.\n * @param {?function(*, ValueType=)=} callback Node-style callback to be\n * called when <code>promise</code> is resolved or rejected.  If\n * <code>promise</code> is rejected with a falsey value the first argument\n * will be an instance of <code>Error</code> with a <code>.cause</code>\n * property with the rejected value.\n * @return {Promise<ValueType>|undefined} <code>undefined</code> if\n * <code>callback</code> is a function, otherwise a <code>Promise</code>\n * which behaves like <code>promise</code> (currently is <code>promise</code>,\n * but is not guaranteed to remain so).\n * @alias module:promise-nodeify\n */\n\n\nfunction promiseNodeify(promise, callback) {\n  if (typeof callback !== 'function') {\n    return promise;\n  }\n\n  function onRejected(reason) {\n    // callback is unlikely to recognize or expect a falsey error.\n    // (we also rely on truthyness for arguments.length in doCallback)\n    // Convert it to something truthy\n    let truthyReason = reason;\n\n    if (!truthyReason) {\n      // Note:  unthenify converts falsey rejections to TypeError:\n      // https://github.com/blakeembrey/unthenify/blob/v1.0.0/src/index.ts#L32\n      // We use bluebird convention for Error, message, and .cause property\n      truthyReason = new Error(String(reason));\n      truthyReason.cause = reason;\n    }\n\n    doCallback(callback, truthyReason);\n  }\n\n  function onResolved(value) {\n    doCallback(callback, null, value);\n  }\n\n  promise.then(onResolved, onRejected);\n  return undefined;\n}\n/** A version of {@link promiseNodeify} which delegates to the\n * <code>.nodeify</code> method on <code>promise</code>, if present.\n *\n * This may be more performant than {@see promiseNodeify} and have additional\n * implementation-specific features, but the behavior may differ from\n * <code>promiseNodeify</code> and between Promise implementations.\n *\n * Note that this function only passes the callback argument to\n * <code>.nodeify</code>, since additional arguments are interpreted\n * differently by different libraries (e.g. bluebird treats the next argument\n * as an options object while then treats it as <code>this</code> for the\n * callback).\n *\n * @ template ValueType\n * @param {!Promise<ValueType>} promise Promise to monitor.\n * @param {?function(*, ValueType=)=} callback Node-style callback.\n * @return {Promise<ValueType>|undefined} Value returned by\n * <code>.nodeify</code>.  Known implementations return the\n * <code>promise</code> argument when callback is falsey and either\n * <code>promise</code> or <code>undefined</code> otherwise.\n */\n\n\npromiseNodeify.delegated = function nodeifyDelegated(promise, callback) {\n  if (typeof promise.nodeify === 'function') {\n    return promise.nodeify(callback);\n  }\n\n  return promiseNodeify(promise, callback);\n};\n/** Polyfill for <code>Promise.prototype.nodeify</code> which behaves like\n * {@link promiseNodeify}.\n *\n * @ template ValueType\n * @this {!Promise<ValueType>}\n * @param {?function(*, ValueType=)=} callback Node-style callback.\n * @return {Promise<ValueType>|undefined} <code>undefined</code> if\n * <code>callback</code> is a function, otherwise a <code>Promise</code>\n * which behaves like <code>promise</code> (currently is <code>promise</code>,\n * but is not guaranteed to remain so).\n */\n\n\npromiseNodeify.nodeifyThis = function nodeifyThis(callback) {\n  return promiseNodeify(this, callback);\n}; // Note: This file is used directly for Node and wrapped in UMD for browser\n\n\nif (typeof exports === 'object') {\n  module.exports = promiseNodeify;\n}","map":{"version":3,"sources":["/Users/xavier/Documents/DeÃÅveloppement/portarch/node_modules/promise-nodeify/index.js"],"names":["later","process","nextTick","setImmediate","setTimeout","doCallback","callback","reason","value","err","promiseNodeify","promise","onRejected","truthyReason","Error","String","cause","onResolved","then","undefined","delegated","nodeifyDelegated","nodeify","nodeifyThis","exports","module"],"mappings":"AAAA;;;;AAKA;AAEA;;;;AAGA,MAAMA,KAAK,GACP,OAAOC,OAAP,KAAmB,WAAnB,IACG,OAAOA,OAAO,CAACC,QAAf,KAA4B,UAD/B,GAC4CD,OAAO,CAACC,QADpD,GAEE,OAAOC,YAAP,KAAwB,UAAxB,GAAqCA,YAArC,GACEC,UAJR;AAMA;;;;AAGA,SAASC,UAAT,CAAoBC,QAApB,EAA8BC,MAA9B,EAAsCC,KAAtC,EAA6C;AAC3C;AACA;AACA;AACA,MAAI;AACF;AACA;AACA;AACA;AACA,QAAID,MAAJ,EAAY;AACVD,MAAAA,QAAQ,CAACC,MAAD,CAAR;AACD,KAFD,MAEO;AACLD,MAAAA,QAAQ,CAAC,IAAD,EAAOE,KAAP,CAAR;AACD;AACF,GAVD,CAUE,OAAOC,GAAP,EAAY;AACZT,IAAAA,KAAK,CAAC,MAAM;AAAE,YAAMS,GAAN;AAAY,KAArB,CAAL;AACD;AACF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,SAASC,cAAT,CAAwBC,OAAxB,EAAiCL,QAAjC,EAA2C;AACzC,MAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;AAClC,WAAOK,OAAP;AACD;;AAED,WAASC,UAAT,CAAoBL,MAApB,EAA4B;AAC1B;AACA;AACA;AACA,QAAIM,YAAY,GAAGN,MAAnB;;AACA,QAAI,CAACM,YAAL,EAAmB;AACjB;AACA;AACA;AACAA,MAAAA,YAAY,GAAG,IAAIC,KAAJ,CAAUC,MAAM,CAACR,MAAD,CAAhB,CAAf;AACAM,MAAAA,YAAY,CAACG,KAAb,GAAqBT,MAArB;AACD;;AAEDF,IAAAA,UAAU,CAACC,QAAD,EAAWO,YAAX,CAAV;AACD;;AAED,WAASI,UAAT,CAAoBT,KAApB,EAA2B;AACzBH,IAAAA,UAAU,CAACC,QAAD,EAAW,IAAX,EAAiBE,KAAjB,CAAV;AACD;;AAEDG,EAAAA,OAAO,CAACO,IAAR,CAAaD,UAAb,EAAyBL,UAAzB;AACA,SAAOO,SAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;AAqBAT,cAAc,CAACU,SAAf,GAA2B,SAASC,gBAAT,CAA0BV,OAA1B,EAAmCL,QAAnC,EAA6C;AACtE,MAAI,OAAOK,OAAO,CAACW,OAAf,KAA2B,UAA/B,EAA2C;AACzC,WAAOX,OAAO,CAACW,OAAR,CAAgBhB,QAAhB,CAAP;AACD;;AAED,SAAOI,cAAc,CAACC,OAAD,EAAUL,QAAV,CAArB;AACD,CAND;AAQA;;;;;;;;;;;;;AAWAI,cAAc,CAACa,WAAf,GAA6B,SAASA,WAAT,CAAqBjB,QAArB,EAA+B;AAC1D,SAAOI,cAAc,CAAC,IAAD,EAAOJ,QAAP,CAArB;AACD,CAFD,C,CAIA;;;AACA,IAAI,OAAOkB,OAAP,KAAmB,QAAvB,EAAiC;AAC/BC,EAAAA,MAAM,CAACD,OAAP,GAAiBd,cAAjB;AACD","sourcesContent":["/** @module promise-nodeify\n * @copyright Copyright 2016-2018 Kevin Locke <kevin@kevinlocke.name>\n * @license MIT\n */\n\n'use strict';\n\n/** Function which will run with a clear stack as soon as possible.\n * @private\n */\nconst later\n  = typeof process !== 'undefined'\n    && typeof process.nextTick === 'function' ? process.nextTick\n    : typeof setImmediate === 'function' ? setImmediate\n      : setTimeout;\n\n/** Invokes callback and ensures any exceptions thrown are uncaught.\n * @private\n */\nfunction doCallback(callback, reason, value) {\n  // Note:  Could delay callback call until later, as When.js does, but this\n  // loses the stack (particularly for bluebird long traces) and causes\n  // unnecessary delay in the non-exception (common) case.\n  try {\n    // Match argument length to resolve/reject in case callback cares.\n    // Note:  bluebird has argument length 1 if value === undefined due to\n    // https://github.com/petkaantonov/bluebird/issues/170\n    // If you are reading this and want similar behavior, I'll consider it.\n    if (reason) {\n      callback(reason);\n    } else {\n      callback(null, value);\n    }\n  } catch (err) {\n    later(() => { throw err; });\n  }\n}\n\n/** Calls a node-style callback when a Promise is resolved or rejected.\n *\n * This function provides the behavior of\n * {@link https://github.com/then/nodeify then <code>nodeify</code>},\n * {@link\n * https://github.com/cujojs/when/blob/master/docs/api.md#nodebindcallback\n * when.js <code>node.bindCallback</code>},\n * or {@link http://bluebirdjs.com/docs/api/ascallback.html bluebird\n * <code>Promise.prototype.nodeify</code> (now\n * <code>Promise.prototype.asCallback</code>)} (without options).\n *\n * @ template ValueType\n * @param {!Promise<ValueType>} promise Promise to monitor.\n * @param {?function(*, ValueType=)=} callback Node-style callback to be\n * called when <code>promise</code> is resolved or rejected.  If\n * <code>promise</code> is rejected with a falsey value the first argument\n * will be an instance of <code>Error</code> with a <code>.cause</code>\n * property with the rejected value.\n * @return {Promise<ValueType>|undefined} <code>undefined</code> if\n * <code>callback</code> is a function, otherwise a <code>Promise</code>\n * which behaves like <code>promise</code> (currently is <code>promise</code>,\n * but is not guaranteed to remain so).\n * @alias module:promise-nodeify\n */\nfunction promiseNodeify(promise, callback) {\n  if (typeof callback !== 'function') {\n    return promise;\n  }\n\n  function onRejected(reason) {\n    // callback is unlikely to recognize or expect a falsey error.\n    // (we also rely on truthyness for arguments.length in doCallback)\n    // Convert it to something truthy\n    let truthyReason = reason;\n    if (!truthyReason) {\n      // Note:  unthenify converts falsey rejections to TypeError:\n      // https://github.com/blakeembrey/unthenify/blob/v1.0.0/src/index.ts#L32\n      // We use bluebird convention for Error, message, and .cause property\n      truthyReason = new Error(String(reason));\n      truthyReason.cause = reason;\n    }\n\n    doCallback(callback, truthyReason);\n  }\n\n  function onResolved(value) {\n    doCallback(callback, null, value);\n  }\n\n  promise.then(onResolved, onRejected);\n  return undefined;\n}\n\n/** A version of {@link promiseNodeify} which delegates to the\n * <code>.nodeify</code> method on <code>promise</code>, if present.\n *\n * This may be more performant than {@see promiseNodeify} and have additional\n * implementation-specific features, but the behavior may differ from\n * <code>promiseNodeify</code> and between Promise implementations.\n *\n * Note that this function only passes the callback argument to\n * <code>.nodeify</code>, since additional arguments are interpreted\n * differently by different libraries (e.g. bluebird treats the next argument\n * as an options object while then treats it as <code>this</code> for the\n * callback).\n *\n * @ template ValueType\n * @param {!Promise<ValueType>} promise Promise to monitor.\n * @param {?function(*, ValueType=)=} callback Node-style callback.\n * @return {Promise<ValueType>|undefined} Value returned by\n * <code>.nodeify</code>.  Known implementations return the\n * <code>promise</code> argument when callback is falsey and either\n * <code>promise</code> or <code>undefined</code> otherwise.\n */\npromiseNodeify.delegated = function nodeifyDelegated(promise, callback) {\n  if (typeof promise.nodeify === 'function') {\n    return promise.nodeify(callback);\n  }\n\n  return promiseNodeify(promise, callback);\n};\n\n/** Polyfill for <code>Promise.prototype.nodeify</code> which behaves like\n * {@link promiseNodeify}.\n *\n * @ template ValueType\n * @this {!Promise<ValueType>}\n * @param {?function(*, ValueType=)=} callback Node-style callback.\n * @return {Promise<ValueType>|undefined} <code>undefined</code> if\n * <code>callback</code> is a function, otherwise a <code>Promise</code>\n * which behaves like <code>promise</code> (currently is <code>promise</code>,\n * but is not guaranteed to remain so).\n */\npromiseNodeify.nodeifyThis = function nodeifyThis(callback) {\n  return promiseNodeify(this, callback);\n};\n\n// Note: This file is used directly for Node and wrapped in UMD for browser\nif (typeof exports === 'object') {\n  module.exports = promiseNodeify;\n}\n"]},"metadata":{},"sourceType":"script"}