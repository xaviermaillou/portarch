{"ast":null,"code":"'use strict';\n\nvar url = require('url');\n\nvar http = require('http');\n\nvar httpRequest = http.request;\n\nvar https = require('https');\n\nvar httpsRequest = https.request;\n\nvar tls = require('tls');\n\nvar util = require('util');\n\nvar ntlm = require('./ntlm');\n\nfunction ProxyingAgent(options, agent) {\n  this.openSockets = {};\n  this.options = util._extend({}, options);\n  this.options.proxy = url.parse(this.options.proxy);\n  this.options.tunnel = this.options.tunnel || false;\n  this.options.ssl = this.options.proxy.protocol ? this.options.proxy.protocol.toLowerCase() == 'https:' : false;\n  this.options.host = this.options.proxy.hostname;\n  this.options.port = this.options.proxy.port || (this.options.ssl ? 443 : 80);\n  this.options.authType = this.options.authType || 'basic';\n\n  if (this.options.authType === 'ntlm') {\n    if (!this.options.proxy.auth) {\n      throw new Error('NTLM authentication credentials must be provided');\n    }\n\n    if (!this.options.ntlm || !this.options.ntlm.domain) {\n      throw new Error('NTLM domain must be provided');\n    }\n  } // base64 decode proxy auth if necessary\n\n\n  var auth = this.options.proxy.auth;\n\n  if (auth && auth.indexOf(':') == -1) {\n    auth = new Buffer(auth, 'base64').toString('ascii'); // if after decoding there still isn't a colon, then revert back to the original value\n\n    if (auth.indexOf(':') == -1) {\n      auth = this.options.proxy.auth;\n    }\n\n    this.options.proxy.auth = auth;\n  } // select the Agent type to use based on the proxy protocol\n\n\n  this.agent = agent;\n  this.agent.call(this, this.options);\n}\n/**\n * Get absolutURI without port when using default\n */\n\n\nProxyingAgent.prototype.getAbsoluteURI = function (ssl, host, port, path) {\n  var absoluteUri = (ssl ? 'https://' : 'http://') + host;\n\n  if (typeof port === 'string') {\n    // Check if target url have specified port and add it to absoluteUri\n    // When port is defined in target url then we get it as a string otherwise it's a number\n    absoluteUri += ':' + port;\n  }\n\n  absoluteUri += path;\n  return absoluteUri;\n};\n/**\n * Overrides the 'addRequest' Agent method for establishing a socket with the proxy\n * that will e used to issue the actual request\n */\n\n\nProxyingAgent.prototype.addRequest = function (req, host, port) {\n  if (typeof host === 'object') {\n    port = host.port;\n    host = host.hostname || host.host;\n  }\n\n  if (this.options.authType === 'ntlm') {\n    this.startNtlm(req, host, port);\n  } else {\n    this.startProxying(req, host, port);\n  }\n};\n/**\n * Start proxying the request through the proxy server.\n * This automatically opens a tunnel through the proxy if needed,\n * or just issues a regular request for the proxy to transfer\n */\n\n\nProxyingAgent.prototype.startProxying = function (req, host, port) {\n  // setup the basic authentication header for the proxy.\n  // we do this only if we haven't already authenticated through NTLM\n  if (this.options.authType == 'basic' && this.options.proxy.auth) {\n    this.authHeader = {\n      header: 'Proxy-Authorization',\n      value: 'Basic ' + new Buffer(this.options.proxy.auth).toString('base64')\n    };\n  } // if we need to create a tunnel to the server via the CONNECT method\n\n\n  if (this.options.tunnel) {\n    var tunnelOptions = util._extend({}, this.options);\n\n    tunnelOptions.method = 'CONNECT';\n    tunnelOptions.path = host + ':' + port;\n    tunnelOptions.hostname = this.options.proxy.hostname;\n    tunnelOptions.port = this.options.proxy.port;\n    tunnelOptions.headers = tunnelOptions.headers || {}; // if we already have a socket open then execute the CONNECT method on it\n\n    var socket = this.getSocket(req);\n\n    if (socket) {\n      tunnelOptions.agent = new SocketAgent(socket);\n    } // add the authentication header\n\n\n    if (this.authHeader) {\n      tunnelOptions.headers[this.authHeader.header] = this.authHeader.value;\n\n      if (this.authHeader.keepAlive) {\n        tunnelOptions.headers[\"Proxy-Connection\"] = \"Keep-Alive\";\n      }\n    } // create a new CONNECT request to the proxy to create the tunnel\n    // to the server\n\n\n    var newReq = this.createNewRequest(tunnelOptions);\n    newReq.once('close', function () {\n      this.emitError(req, 'Tunnel creation failed. Socket closed prematurely');\n    }.bind(this));\n    newReq.once('error', function (error) {\n      this.emitError(req, 'Tunnel creation failed. Socket error: ' + error);\n    }.bind(this)); // listen for the CONNECT event to complete and execute the original request\n    // on the TLSed socket\n\n    newReq.once('connect', function (response, socket, head) {\n      newReq.removeAllListeners();\n\n      if (response.statusCode != 200) {\n        this.emitError(req, 'Tunnel creation failed. Received status code ' + response.statusCode);\n        return;\n      }\n\n      var tlsOptions = this.options.tlsOptions || {};\n      tlsOptions.socket = response.socket;\n      tlsOptions.servername = host; // upgrade the socket to TLS\n\n      var tlsSocket = tls.connect(tlsOptions, function () {\n        this.setSocket(req, tlsSocket);\n        this.execRequest(req, this.options.host, this.options.port);\n      }.bind(this));\n      tlsSocket.once('error', function (error) {\n        this.emitError(req, 'Tunnel socket error: ' + error);\n      }.bind(this));\n    }.bind(this)); // execute the CONNECT method to create the tunnel\n\n    newReq.end();\n  } else {\n    // issue a regular proxy request\n    req.path = this.getAbsoluteURI(this.options.ssl, host, port, req.path);\n\n    if (this.authHeader) {\n      req.setHeader(this.authHeader.header, this.authHeader.value);\n    }\n\n    this.execRequest(req, this.options.host, this.options.port);\n  }\n};\n/**\n * Start an NTLM authentication process. The result is an open socket that will be used\n * to issue the actual request or open a tunnel on\n */\n\n\nProxyingAgent.prototype.startNtlm = function (req, host, port) {\n  var ntlmOptions = util._extend({}, this.options);\n\n  ntlmOptions.method = ntlmOptions.method || 'GET'; // just for the NTLM handshake\n\n  ntlmOptions.path = this.getAbsoluteURI(this.options.ssl, host, port, req.path);\n  ntlmOptions.ntlm.workstation = ntlmOptions.ntlm.workstation || require('os').hostname();\n  var creds = this.options.proxy.auth.match(/([^:]*):?(.*)/);\n  ntlmOptions.ntlm.username = creds[1];\n  ntlmOptions.ntlm.password = creds[2]; // set the NTLM type 1 message header\n\n  ntlmOptions.headers = ntlmOptions.headers || {};\n  ntlmOptions.headers['Proxy-Authorization'] = ntlm.createType1Message(ntlmOptions.ntlm);\n  ntlmOptions.headers['Proxy-Connection'] = \"Keep-Alive\"; // create the NTLM type 1 request\n\n  var newReq = this.createNewRequest(ntlmOptions); // capture the response and set the NTLM type 3 authorization header\n  // that will be used when issuing the actual request\n\n  newReq.once('response', function (response) {\n    if (response.statusCode !== 407 || !response.headers['proxy-authenticate']) {\n      this.emitError(req, 'did not receive NTLM type 2 message');\n      return;\n    }\n\n    var type2msg = ntlm.parseType2Message(response.headers['proxy-authenticate'], function (error) {\n      this.emitError(req, error);\n      return null;\n    }.bind(this));\n\n    if (!type2msg) {\n      return;\n    } // capture the socket\n\n\n    this.setSocket(req, response.socket);\n    this.authHeader = {\n      header: 'Proxy-Authorization',\n      value: ntlm.createType3Message(type2msg, ntlmOptions.ntlm),\n      keepAlive: true\n    }; // read all the data from the socket as it may contain a body that should be discarded\n\n    response.on('data', function () {// just consume the body\n    }.bind(this)); // start proxying\n\n    this.startProxying(req, host, port);\n  }.bind(this)); // start proxying the actual request only when there is not more body to read.\n  // the socket should have already been captured and associated with the request\n\n  newReq.once('close', function () {\n    this.emitError(req, 'NTLM failed. Socket closed prematurely');\n  }.bind(this));\n  newReq.once('error', function (error) {\n    this.emitError(req, 'NTLM failed. Socket error: ' + error);\n  }.bind(this)); // issue the NTLM type 1 request\n\n  newReq.end();\n};\n/**\n * Create a new request instance according the needed security\n */\n\n\nProxyingAgent.prototype.createNewRequest = function (options) {\n  if (options.ssl) {\n    return new httpsRequest(options);\n  }\n\n  return new httpRequest(options);\n};\n/**\n * Execute the provided request by invoking the original Agent 'addRequest' method.\n * If there is already a socket that was associated with the request, then it\n * will be used for issuing the request (via the 'createSocket' method)\n */\n\n\nProxyingAgent.prototype.execRequest = function (req, host, port) {\n  this.agent.prototype.addRequest.call(this, req, host, port); // if there is an associated socket to this request then the association is removed\n  // since the socket was already passed to the request\n\n  if (this.openSockets[req]) {\n    delete this.openSockets[req];\n  }\n};\n/**\n * Remember a socket and associate it with a specific request.\n * When the 'createSocket' method will be called to execute the actual request\n * then the already existing socket will be used\n */\n\n\nProxyingAgent.prototype.setSocket = function (req, socket) {\n  this.openSockets[req] = socket;\n\n  var onClose = function () {\n    if (this.openSockets[req]) {\n      delete this.openSockets[req];\n    }\n  }.bind(this);\n\n  this.openSockets[req].on('close', onClose);\n};\n\nProxyingAgent.prototype.getSocket = function (req) {\n  return this.openSockets[req];\n};\n/**\n * This is called during the 'addRequest' call of the original Agent to return a\n * new socket for executing the request. If a socket already exists then it is used\n * instead of creating a new one.\n */\n\n\nProxyingAgent.prototype.createSocket = function () {\n  var req;\n  var cb;\n\n  if (typeof arguments[0] === 'object') {\n    req = arguments[0];\n    cb = arguments[2];\n  } else {\n    req = arguments[4];\n  }\n\n  if (this.openSockets[req]) {\n    if (cb) {\n      return cb(null, this.openSockets[req]);\n    } else {\n      return this.openSockets[req];\n    }\n  }\n\n  return this.agent.prototype.createSocket.apply(this, arguments);\n};\n\nProxyingAgent.prototype.emitError = function (req, message) {\n  (req.socket || req).emit('error', new Error(message));\n}; //======= SocketAgent\n\n/**\n * A simple agent to execute a request on a given socket\n */\n\n\nfunction SocketAgent(socket) {\n  this.socket = socket;\n}\n\nSocketAgent.prototype.addRequest = function (req, host, port) {\n  req.onSocket(this.socket);\n};\n/**\n * HttpProxyingAgent\n * @param options\n * @constructor\n */\n\n\nfunction HttpProxyingAgent(options) {\n  ProxyingAgent.call(this, options, http.Agent);\n}\n\nutil.inherits(HttpProxyingAgent, http.Agent);\n\nutil._extend(HttpProxyingAgent.prototype, ProxyingAgent.prototype);\n/**\n * HttpsProxyingAgent\n * @param options\n * @constructor\n */\n\n\nfunction HttpsProxyingAgent(options) {\n  options.tunnel = true;\n  ProxyingAgent.call(this, options, https.Agent);\n}\n\nutil.inherits(HttpsProxyingAgent, https.Agent);\n\nutil._extend(HttpsProxyingAgent.prototype, ProxyingAgent.prototype);\n/**\n * Create the proxying agent\n * @param proxy\n * @param target\n * @returns {*}\n */\n\n\nexports.create = function (proxy, target) {\n  if (typeof proxy === 'string') {\n    proxy = {\n      proxy: proxy\n    };\n  }\n\n  if (target.toLowerCase().indexOf('https:') === 0) {\n    return new HttpsProxyingAgent(proxy);\n  }\n\n  return new HttpProxyingAgent(proxy);\n};\n/**\n * Set a global agent to forward all http and https requests through the specified proxy\n * @param proxy\n */\n\n\nexports.globalize = function (proxy) {\n  var copyProxy = JSON.parse(JSON.stringify(proxy));\n  var copySecureProxy = JSON.parse(JSON.stringify(proxy));\n  var secureAgent = this.create(copySecureProxy, 'https://');\n  var nonSecureAgent = this.create(copyProxy, 'http://');\n\n  http.request = function (options, callback) {\n    if (typeof options === 'string') {\n      options = url.parse(options);\n    }\n\n    if (!options.agent) {\n      options.agent = nonSecureAgent;\n    }\n\n    return httpRequest(options, callback);\n  };\n\n  http.get = function get(options, cb) {\n    const req = http.request(options, cb);\n    req.end();\n    return req;\n  };\n\n  https.request = function (options, callback) {\n    if (typeof options === 'string') {\n      options = url.parse(options);\n    }\n\n    if (!options.agent) {\n      options.agent = secureAgent;\n    }\n\n    return httpsRequest(options, callback);\n  };\n\n  https.get = function get(options, cb) {\n    const req = https.request(options, cb);\n    req.end();\n    return req;\n  };\n};","map":{"version":3,"sources":["/Users/xavier/Documents/Développement/portarch/node_modules/proxying-agent/lib/proxying-agent.js"],"names":["url","require","http","httpRequest","request","https","httpsRequest","tls","util","ntlm","ProxyingAgent","options","agent","openSockets","_extend","proxy","parse","tunnel","ssl","protocol","toLowerCase","host","hostname","port","authType","auth","Error","domain","indexOf","Buffer","toString","call","prototype","getAbsoluteURI","path","absoluteUri","addRequest","req","startNtlm","startProxying","authHeader","header","value","tunnelOptions","method","headers","socket","getSocket","SocketAgent","keepAlive","newReq","createNewRequest","once","emitError","bind","error","response","head","removeAllListeners","statusCode","tlsOptions","servername","tlsSocket","connect","setSocket","execRequest","end","setHeader","ntlmOptions","workstation","creds","match","username","password","createType1Message","type2msg","parseType2Message","createType3Message","on","onClose","createSocket","cb","arguments","apply","message","emit","onSocket","HttpProxyingAgent","Agent","inherits","HttpsProxyingAgent","exports","create","target","globalize","copyProxy","JSON","stringify","copySecureProxy","secureAgent","nonSecureAgent","callback","get"],"mappings":"AAAA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,KAAD,CAAjB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIE,WAAW,GAAGD,IAAI,CAACE,OAAvB;;AACA,IAAIC,KAAK,GAAGJ,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAIK,YAAY,GAAGD,KAAK,CAACD,OAAzB;;AACA,IAAIG,GAAG,GAAGN,OAAO,CAAC,KAAD,CAAjB;;AACA,IAAIO,IAAI,GAAGP,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIQ,IAAI,GAAGR,OAAO,CAAC,QAAD,CAAlB;;AAEA,SAASS,aAAT,CAAuBC,OAAvB,EAAgCC,KAAhC,EAAuC;AACrC,OAAKC,WAAL,GAAmB,EAAnB;AACA,OAAKF,OAAL,GAAeH,IAAI,CAACM,OAAL,CAAa,EAAb,EAAiBH,OAAjB,CAAf;AACA,OAAKA,OAAL,CAAaI,KAAb,GAAqBf,GAAG,CAACgB,KAAJ,CAAU,KAAKL,OAAL,CAAaI,KAAvB,CAArB;AACA,OAAKJ,OAAL,CAAaM,MAAb,GAAsB,KAAKN,OAAL,CAAaM,MAAb,IAAuB,KAA7C;AACA,OAAKN,OAAL,CAAaO,GAAb,GAAmB,KAAKP,OAAL,CAAaI,KAAb,CAAmBI,QAAnB,GAA8B,KAAKR,OAAL,CAAaI,KAAb,CAAmBI,QAAnB,CAA4BC,WAA5B,MAA6C,QAA3E,GAAsF,KAAzG;AACA,OAAKT,OAAL,CAAaU,IAAb,GAAoB,KAAKV,OAAL,CAAaI,KAAb,CAAmBO,QAAvC;AACA,OAAKX,OAAL,CAAaY,IAAb,GAAoB,KAAKZ,OAAL,CAAaI,KAAb,CAAmBQ,IAAnB,KAA4B,KAAKZ,OAAL,CAAaO,GAAb,GAAmB,GAAnB,GAAyB,EAArD,CAApB;AACA,OAAKP,OAAL,CAAaa,QAAb,GAAwB,KAAKb,OAAL,CAAaa,QAAb,IAAyB,OAAjD;;AAEA,MAAI,KAAKb,OAAL,CAAaa,QAAb,KAA0B,MAA9B,EAAsC;AACpC,QAAI,CAAC,KAAKb,OAAL,CAAaI,KAAb,CAAmBU,IAAxB,EAA8B;AAC5B,YAAM,IAAIC,KAAJ,CAAU,kDAAV,CAAN;AACD;;AACD,QAAI,CAAC,KAAKf,OAAL,CAAaF,IAAd,IAAsB,CAAC,KAAKE,OAAL,CAAaF,IAAb,CAAkBkB,MAA7C,EAAqD;AACnD,YAAM,IAAID,KAAJ,CAAU,8BAAV,CAAN;AACD;AACF,GAjBoC,CAmBrC;;;AACA,MAAID,IAAI,GAAG,KAAKd,OAAL,CAAaI,KAAb,CAAmBU,IAA9B;;AACA,MAAIA,IAAI,IAAIA,IAAI,CAACG,OAAL,CAAa,GAAb,KAAqB,CAAC,CAAlC,EAAqC;AACnCH,IAAAA,IAAI,GAAG,IAAII,MAAJ,CAAWJ,IAAX,EAAiB,QAAjB,EAA2BK,QAA3B,CAAoC,OAApC,CAAP,CADmC,CAEnC;;AACA,QAAIL,IAAI,CAACG,OAAL,CAAa,GAAb,KAAqB,CAAC,CAA1B,EAA6B;AAC3BH,MAAAA,IAAI,GAAG,KAAKd,OAAL,CAAaI,KAAb,CAAmBU,IAA1B;AACD;;AACD,SAAKd,OAAL,CAAaI,KAAb,CAAmBU,IAAnB,GAA0BA,IAA1B;AACD,GA5BoC,CA8BrC;;;AACA,OAAKb,KAAL,GAAaA,KAAb;AACA,OAAKA,KAAL,CAAWmB,IAAX,CAAgB,IAAhB,EAAsB,KAAKpB,OAA3B;AACD;AAED;;;;;AAGAD,aAAa,CAACsB,SAAd,CAAwBC,cAAxB,GAAyC,UAASf,GAAT,EAAcG,IAAd,EAAoBE,IAApB,EAA0BW,IAA1B,EAAgC;AACvE,MAAIC,WAAW,GAAG,CAACjB,GAAG,GAAG,UAAH,GAAgB,SAApB,IAAiCG,IAAnD;;AAEA,MAAI,OAAOE,IAAP,KAAgB,QAApB,EAA8B;AAC5B;AACA;AACAY,IAAAA,WAAW,IAAI,MAAMZ,IAArB;AACD;;AAEDY,EAAAA,WAAW,IAAID,IAAf;AAEA,SAAOC,WAAP;AACD,CAZD;AAcA;;;;;;AAIAzB,aAAa,CAACsB,SAAd,CAAwBI,UAAxB,GAAqC,UAASC,GAAT,EAAchB,IAAd,EAAoBE,IAApB,EAA0B;AAC7D,MAAI,OAAOF,IAAP,KAAgB,QAApB,EAA8B;AAC5BE,IAAAA,IAAI,GAAGF,IAAI,CAACE,IAAZ;AACAF,IAAAA,IAAI,GAAGA,IAAI,CAACC,QAAL,IAAiBD,IAAI,CAACA,IAA7B;AACD;;AACD,MAAI,KAAKV,OAAL,CAAaa,QAAb,KAA0B,MAA9B,EAAsC;AACpC,SAAKc,SAAL,CAAeD,GAAf,EAAoBhB,IAApB,EAA0BE,IAA1B;AACD,GAFD,MAEO;AACL,SAAKgB,aAAL,CAAmBF,GAAnB,EAAwBhB,IAAxB,EAA8BE,IAA9B;AACD;AACF,CAVD;AAYA;;;;;;;AAKAb,aAAa,CAACsB,SAAd,CAAwBO,aAAxB,GAAwC,UAASF,GAAT,EAAchB,IAAd,EAAoBE,IAApB,EAA0B;AAEhE;AACA;AACA,MAAI,KAAKZ,OAAL,CAAaa,QAAb,IAAyB,OAAzB,IAAoC,KAAKb,OAAL,CAAaI,KAAb,CAAmBU,IAA3D,EAAiE;AAC/D,SAAKe,UAAL,GAAkB;AAChBC,MAAAA,MAAM,EAAE,qBADQ;AAEhBC,MAAAA,KAAK,EAAE,WAAW,IAAIb,MAAJ,CAAW,KAAKlB,OAAL,CAAaI,KAAb,CAAmBU,IAA9B,EAAoCK,QAApC,CAA6C,QAA7C;AAFF,KAAlB;AAID,GAT+D,CAWhE;;;AACA,MAAI,KAAKnB,OAAL,CAAaM,MAAjB,EAAyB;AACvB,QAAI0B,aAAa,GAAGnC,IAAI,CAACM,OAAL,CAAa,EAAb,EAAiB,KAAKH,OAAtB,CAApB;;AACAgC,IAAAA,aAAa,CAACC,MAAd,GAAuB,SAAvB;AACAD,IAAAA,aAAa,CAACT,IAAd,GAAqBb,IAAI,GAAC,GAAL,GAASE,IAA9B;AACAoB,IAAAA,aAAa,CAACrB,QAAd,GAAyB,KAAKX,OAAL,CAAaI,KAAb,CAAmBO,QAA5C;AACAqB,IAAAA,aAAa,CAACpB,IAAd,GAAqB,KAAKZ,OAAL,CAAaI,KAAb,CAAmBQ,IAAxC;AACAoB,IAAAA,aAAa,CAACE,OAAd,GAAwBF,aAAa,CAACE,OAAd,IAAyB,EAAjD,CANuB,CAQvB;;AACA,QAAIC,MAAM,GAAG,KAAKC,SAAL,CAAeV,GAAf,CAAb;;AACA,QAAIS,MAAJ,EAAY;AACVH,MAAAA,aAAa,CAAC/B,KAAd,GAAsB,IAAIoC,WAAJ,CAAgBF,MAAhB,CAAtB;AACD,KAZsB,CAcvB;;;AACA,QAAI,KAAKN,UAAT,EAAqB;AACnBG,MAAAA,aAAa,CAACE,OAAd,CAAsB,KAAKL,UAAL,CAAgBC,MAAtC,IAAgD,KAAKD,UAAL,CAAgBE,KAAhE;;AACA,UAAI,KAAKF,UAAL,CAAgBS,SAApB,EAA+B;AAC7BN,QAAAA,aAAa,CAACE,OAAd,CAAsB,kBAAtB,IAA4C,YAA5C;AACD;AACF,KApBsB,CAsBvB;AACA;;;AACA,QAAIK,MAAM,GAAG,KAAKC,gBAAL,CAAsBR,aAAtB,CAAb;AAEAO,IAAAA,MAAM,CAACE,IAAP,CAAY,OAAZ,EAAqB,YAAW;AAC9B,WAAKC,SAAL,CAAehB,GAAf,EAAoB,mDAApB;AACD,KAFoB,CAEnBiB,IAFmB,CAEd,IAFc,CAArB;AAIAJ,IAAAA,MAAM,CAACE,IAAP,CAAY,OAAZ,EAAqB,UAASG,KAAT,EAAgB;AACnC,WAAKF,SAAL,CAAehB,GAAf,EAAoB,2CAA2CkB,KAA/D;AACD,KAFoB,CAEnBD,IAFmB,CAEd,IAFc,CAArB,EA9BuB,CAkCvB;AACA;;AACAJ,IAAAA,MAAM,CAACE,IAAP,CAAY,SAAZ,EAAuB,UAASI,QAAT,EAAmBV,MAAnB,EAA2BW,IAA3B,EAAiC;AACtDP,MAAAA,MAAM,CAACQ,kBAAP;;AACA,UAAIF,QAAQ,CAACG,UAAT,IAAuB,GAA3B,EAAgC;AAC9B,aAAKN,SAAL,CAAehB,GAAf,EAAoB,kDAAkDmB,QAAQ,CAACG,UAA/E;AACA;AACD;;AACD,UAAIC,UAAU,GAAG,KAAKjD,OAAL,CAAaiD,UAAb,IAA2B,EAA5C;AACAA,MAAAA,UAAU,CAACd,MAAX,GAAoBU,QAAQ,CAACV,MAA7B;AACAc,MAAAA,UAAU,CAACC,UAAX,GAAwBxC,IAAxB,CARsD,CAUtD;;AACA,UAAIyC,SAAS,GAAGvD,GAAG,CAACwD,OAAJ,CAAYH,UAAZ,EAAwB,YAAW;AACjD,aAAKI,SAAL,CAAe3B,GAAf,EAAoByB,SAApB;AACA,aAAKG,WAAL,CAAiB5B,GAAjB,EAAsB,KAAK1B,OAAL,CAAaU,IAAnC,EAAyC,KAAKV,OAAL,CAAaY,IAAtD;AACD,OAHuC,CAGtC+B,IAHsC,CAGjC,IAHiC,CAAxB,CAAhB;AAKAQ,MAAAA,SAAS,CAACV,IAAV,CAAe,OAAf,EAAwB,UAASG,KAAT,EAAgB;AACtC,aAAKF,SAAL,CAAehB,GAAf,EAAoB,0BAA0BkB,KAA9C;AACD,OAFuB,CAEtBD,IAFsB,CAEjB,IAFiB,CAAxB;AAID,KApBsB,CAoBrBA,IApBqB,CAoBhB,IApBgB,CAAvB,EApCuB,CA0DvB;;AACAJ,IAAAA,MAAM,CAACgB,GAAP;AACD,GA5DD,MA4DO;AACL;AACA7B,IAAAA,GAAG,CAACH,IAAJ,GAAW,KAAKD,cAAL,CAAoB,KAAKtB,OAAL,CAAaO,GAAjC,EAAsCG,IAAtC,EAA4CE,IAA5C,EAAkDc,GAAG,CAACH,IAAtD,CAAX;;AACA,QAAI,KAAKM,UAAT,EAAqB;AACnBH,MAAAA,GAAG,CAAC8B,SAAJ,CAAc,KAAK3B,UAAL,CAAgBC,MAA9B,EAAsC,KAAKD,UAAL,CAAgBE,KAAtD;AACD;;AACD,SAAKuB,WAAL,CAAiB5B,GAAjB,EAAsB,KAAK1B,OAAL,CAAaU,IAAnC,EAAyC,KAAKV,OAAL,CAAaY,IAAtD;AACD;AACF,CAhFD;AAkFA;;;;;;AAIAb,aAAa,CAACsB,SAAd,CAAwBM,SAAxB,GAAoC,UAASD,GAAT,EAAchB,IAAd,EAAoBE,IAApB,EAA0B;AAC5D,MAAI6C,WAAW,GAAG5D,IAAI,CAACM,OAAL,CAAa,EAAb,EAAiB,KAAKH,OAAtB,CAAlB;;AACAyD,EAAAA,WAAW,CAACxB,MAAZ,GAAqBwB,WAAW,CAACxB,MAAZ,IAAsB,KAA3C,CAF4D,CAEV;;AAClDwB,EAAAA,WAAW,CAAClC,IAAZ,GAAmB,KAAKD,cAAL,CAAoB,KAAKtB,OAAL,CAAaO,GAAjC,EAAsCG,IAAtC,EAA4CE,IAA5C,EAAkDc,GAAG,CAACH,IAAtD,CAAnB;AACAkC,EAAAA,WAAW,CAAC3D,IAAZ,CAAiB4D,WAAjB,GAA+BD,WAAW,CAAC3D,IAAZ,CAAiB4D,WAAjB,IAAgCpE,OAAO,CAAC,IAAD,CAAP,CAAcqB,QAAd,EAA/D;AAEA,MAAIgD,KAAK,GAAG,KAAK3D,OAAL,CAAaI,KAAb,CAAmBU,IAAnB,CAAwB8C,KAAxB,CAA8B,eAA9B,CAAZ;AACAH,EAAAA,WAAW,CAAC3D,IAAZ,CAAiB+D,QAAjB,GAA4BF,KAAK,CAAC,CAAD,CAAjC;AACAF,EAAAA,WAAW,CAAC3D,IAAZ,CAAiBgE,QAAjB,GAA4BH,KAAK,CAAC,CAAD,CAAjC,CAR4D,CAU5D;;AACAF,EAAAA,WAAW,CAACvB,OAAZ,GAAsBuB,WAAW,CAACvB,OAAZ,IAAuB,EAA7C;AACAuB,EAAAA,WAAW,CAACvB,OAAZ,CAAoB,qBAApB,IAA6CpC,IAAI,CAACiE,kBAAL,CAAwBN,WAAW,CAAC3D,IAApC,CAA7C;AACA2D,EAAAA,WAAW,CAACvB,OAAZ,CAAoB,kBAApB,IAA0C,YAA1C,CAb4D,CAe5D;;AACA,MAAIK,MAAM,GAAG,KAAKC,gBAAL,CAAsBiB,WAAtB,CAAb,CAhB4D,CAkB5D;AACA;;AACAlB,EAAAA,MAAM,CAACE,IAAP,CAAY,UAAZ,EAAwB,UAASI,QAAT,EAAmB;AACzC,QAAIA,QAAQ,CAACG,UAAT,KAAwB,GAAxB,IAA+B,CAACH,QAAQ,CAACX,OAAT,CAAiB,oBAAjB,CAApC,EAA4E;AAC1E,WAAKQ,SAAL,CAAehB,GAAf,EAAoB,qCAApB;AACA;AACD;;AACD,QAAIsC,QAAQ,GAAGlE,IAAI,CAACmE,iBAAL,CAAuBpB,QAAQ,CAACX,OAAT,CAAiB,oBAAjB,CAAvB,EAA+D,UAASU,KAAT,EAAgB;AAC5F,WAAKF,SAAL,CAAehB,GAAf,EAAoBkB,KAApB;AACA,aAAO,IAAP;AACD,KAH6E,CAG5ED,IAH4E,CAGvE,IAHuE,CAA/D,CAAf;;AAKA,QAAI,CAACqB,QAAL,EAAe;AACb;AACD,KAZwC,CAczC;;;AACA,SAAKX,SAAL,CAAe3B,GAAf,EAAoBmB,QAAQ,CAACV,MAA7B;AAEA,SAAKN,UAAL,GAAkB;AAChBC,MAAAA,MAAM,EAAE,qBADQ;AAEhBC,MAAAA,KAAK,EAAEjC,IAAI,CAACoE,kBAAL,CAAwBF,QAAxB,EAAkCP,WAAW,CAAC3D,IAA9C,CAFS;AAGhBwC,MAAAA,SAAS,EAAE;AAHK,KAAlB,CAjByC,CAuBzC;;AACAO,IAAAA,QAAQ,CAACsB,EAAT,CAAY,MAAZ,EAAoB,YAAW,CAC7B;AACD,KAFmB,CAElBxB,IAFkB,CAEb,IAFa,CAApB,EAxByC,CA4BzC;;AACA,SAAKf,aAAL,CAAmBF,GAAnB,EAAwBhB,IAAxB,EAA8BE,IAA9B;AAED,GA/BuB,CA+BtB+B,IA/BsB,CA+BjB,IA/BiB,CAAxB,EApB4D,CAqD5D;AACA;;AACAJ,EAAAA,MAAM,CAACE,IAAP,CAAY,OAAZ,EAAqB,YAAW;AAC9B,SAAKC,SAAL,CAAehB,GAAf,EAAoB,wCAApB;AACD,GAFoB,CAEnBiB,IAFmB,CAEd,IAFc,CAArB;AAIAJ,EAAAA,MAAM,CAACE,IAAP,CAAY,OAAZ,EAAqB,UAASG,KAAT,EAAgB;AACnC,SAAKF,SAAL,CAAehB,GAAf,EAAoB,gCAAgCkB,KAApD;AACD,GAFoB,CAEnBD,IAFmB,CAEd,IAFc,CAArB,EA3D4D,CA+D5D;;AACAJ,EAAAA,MAAM,CAACgB,GAAP;AACD,CAjED;AAmEA;;;;;AAGAxD,aAAa,CAACsB,SAAd,CAAwBmB,gBAAxB,GAA2C,UAASxC,OAAT,EAAkB;AAC3D,MAAIA,OAAO,CAACO,GAAZ,EAAiB;AACf,WAAO,IAAIZ,YAAJ,CAAiBK,OAAjB,CAAP;AACD;;AACC,SAAO,IAAIR,WAAJ,CAAgBQ,OAAhB,CAAP;AACH,CALD;AAOA;;;;;;;AAKAD,aAAa,CAACsB,SAAd,CAAwBiC,WAAxB,GAAsC,UAAS5B,GAAT,EAAchB,IAAd,EAAoBE,IAApB,EAA0B;AAC9D,OAAKX,KAAL,CAAWoB,SAAX,CAAqBI,UAArB,CAAgCL,IAAhC,CAAqC,IAArC,EAA2CM,GAA3C,EAAgDhB,IAAhD,EAAsDE,IAAtD,EAD8D,CAG9D;AACA;;AACA,MAAI,KAAKV,WAAL,CAAiBwB,GAAjB,CAAJ,EAA2B;AACzB,WAAO,KAAKxB,WAAL,CAAiBwB,GAAjB,CAAP;AACD;AACF,CARD;AAUA;;;;;;;AAKA3B,aAAa,CAACsB,SAAd,CAAwBgC,SAAxB,GAAoC,UAAS3B,GAAT,EAAcS,MAAd,EAAsB;AAExD,OAAKjC,WAAL,CAAiBwB,GAAjB,IAAwBS,MAAxB;;AACA,MAAIiC,OAAO,GAAG,YAAW;AACvB,QAAI,KAAKlE,WAAL,CAAiBwB,GAAjB,CAAJ,EAA2B;AACzB,aAAO,KAAKxB,WAAL,CAAiBwB,GAAjB,CAAP;AACD;AACF,GAJa,CAIZiB,IAJY,CAIP,IAJO,CAAd;;AAKA,OAAKzC,WAAL,CAAiBwB,GAAjB,EAAsByC,EAAtB,CAAyB,OAAzB,EAAkCC,OAAlC;AACD,CATD;;AAWArE,aAAa,CAACsB,SAAd,CAAwBe,SAAxB,GAAoC,UAASV,GAAT,EAAc;AAChD,SAAO,KAAKxB,WAAL,CAAiBwB,GAAjB,CAAP;AACD,CAFD;AAIA;;;;;;;AAKA3B,aAAa,CAACsB,SAAd,CAAwBgD,YAAxB,GAAuC,YAAW;AAEhD,MAAI3C,GAAJ;AACA,MAAI4C,EAAJ;;AACA,MAAI,OAAOC,SAAS,CAAC,CAAD,CAAhB,KAAwB,QAA5B,EAAsC;AACpC7C,IAAAA,GAAG,GAAG6C,SAAS,CAAC,CAAD,CAAf;AACAD,IAAAA,EAAE,GAAGC,SAAS,CAAC,CAAD,CAAd;AACD,GAHD,MAGO;AACL7C,IAAAA,GAAG,GAAG6C,SAAS,CAAC,CAAD,CAAf;AACD;;AAED,MAAI,KAAKrE,WAAL,CAAiBwB,GAAjB,CAAJ,EAA2B;AACzB,QAAI4C,EAAJ,EAAQ;AACN,aAAOA,EAAE,CAAC,IAAD,EAAO,KAAKpE,WAAL,CAAiBwB,GAAjB,CAAP,CAAT;AACD,KAFD,MAEO;AACL,aAAO,KAAKxB,WAAL,CAAiBwB,GAAjB,CAAP;AACD;AACF;;AACD,SAAO,KAAKzB,KAAL,CAAWoB,SAAX,CAAqBgD,YAArB,CAAkCG,KAAlC,CAAwC,IAAxC,EAA8CD,SAA9C,CAAP;AACD,CAnBD;;AAqBAxE,aAAa,CAACsB,SAAd,CAAwBqB,SAAxB,GAAoC,UAAShB,GAAT,EAAc+C,OAAd,EAAuB;AACzD,GAAC/C,GAAG,CAACS,MAAJ,IAAcT,GAAf,EAAoBgD,IAApB,CAAyB,OAAzB,EAAkC,IAAI3D,KAAJ,CAAU0D,OAAV,CAAlC;AACD,CAFD,C,CAKA;;AAEA;;;;;AAGA,SAASpC,WAAT,CAAqBF,MAArB,EAA6B;AAC3B,OAAKA,MAAL,GAAcA,MAAd;AACD;;AAEDE,WAAW,CAAChB,SAAZ,CAAsBI,UAAtB,GAAmC,UAASC,GAAT,EAAchB,IAAd,EAAoBE,IAApB,EAA0B;AAC3Dc,EAAAA,GAAG,CAACiD,QAAJ,CAAa,KAAKxC,MAAlB;AACD,CAFD;AAIA;;;;;;;AAKA,SAASyC,iBAAT,CAA2B5E,OAA3B,EAAoC;AAClCD,EAAAA,aAAa,CAACqB,IAAd,CAAmB,IAAnB,EAAyBpB,OAAzB,EAAkCT,IAAI,CAACsF,KAAvC;AACD;;AACDhF,IAAI,CAACiF,QAAL,CAAcF,iBAAd,EAAiCrF,IAAI,CAACsF,KAAtC;;AACAhF,IAAI,CAACM,OAAL,CAAayE,iBAAiB,CAACvD,SAA/B,EAA0CtB,aAAa,CAACsB,SAAxD;AAEA;;;;;;;AAKA,SAAS0D,kBAAT,CAA4B/E,OAA5B,EAAqC;AACnCA,EAAAA,OAAO,CAACM,MAAR,GAAiB,IAAjB;AACAP,EAAAA,aAAa,CAACqB,IAAd,CAAmB,IAAnB,EAAyBpB,OAAzB,EAAkCN,KAAK,CAACmF,KAAxC;AACD;;AACDhF,IAAI,CAACiF,QAAL,CAAcC,kBAAd,EAAkCrF,KAAK,CAACmF,KAAxC;;AACAhF,IAAI,CAACM,OAAL,CAAa4E,kBAAkB,CAAC1D,SAAhC,EAA2CtB,aAAa,CAACsB,SAAzD;AAEA;;;;;;;;AAMA2D,OAAO,CAACC,MAAR,GAAiB,UAAS7E,KAAT,EAAgB8E,MAAhB,EAAwB;AACvC,MAAI,OAAO9E,KAAP,KAAiB,QAArB,EAA+B;AAC7BA,IAAAA,KAAK,GAAG;AAACA,MAAAA,KAAK,EAAEA;AAAR,KAAR;AACD;;AAED,MAAI8E,MAAM,CAACzE,WAAP,GAAqBQ,OAArB,CAA6B,QAA7B,MAA2C,CAA/C,EAAkD;AAChD,WAAO,IAAI8D,kBAAJ,CAAuB3E,KAAvB,CAAP;AACD;;AACD,SAAO,IAAIwE,iBAAJ,CAAsBxE,KAAtB,CAAP;AACD,CATD;AAWA;;;;;;AAIA4E,OAAO,CAACG,SAAR,GAAoB,UAAU/E,KAAV,EAAiB;AACjC,MAAIgF,SAAS,GAAGC,IAAI,CAAChF,KAAL,CAAWgF,IAAI,CAACC,SAAL,CAAelF,KAAf,CAAX,CAAhB;AACA,MAAImF,eAAe,GAAGF,IAAI,CAAChF,KAAL,CAAWgF,IAAI,CAACC,SAAL,CAAelF,KAAf,CAAX,CAAtB;AACA,MAAIoF,WAAW,GAAG,KAAKP,MAAL,CAAYM,eAAZ,EAA6B,UAA7B,CAAlB;AACA,MAAIE,cAAc,GAAG,KAAKR,MAAL,CAAYG,SAAZ,EAAuB,SAAvB,CAArB;;AAEA7F,EAAAA,IAAI,CAACE,OAAL,GAAe,UAAUO,OAAV,EAAmB0F,QAAnB,EAA6B;AACxC,QAAI,OAAO1F,OAAP,KAAmB,QAAvB,EAAiC;AAC7BA,MAAAA,OAAO,GAAGX,GAAG,CAACgB,KAAJ,CAAUL,OAAV,CAAV;AACH;;AACD,QAAI,CAACA,OAAO,CAACC,KAAb,EAAoB;AAClBD,MAAAA,OAAO,CAACC,KAAR,GAAgBwF,cAAhB;AACD;;AACD,WAAOjG,WAAW,CAACQ,OAAD,EAAU0F,QAAV,CAAlB;AACH,GARD;;AAUAnG,EAAAA,IAAI,CAACoG,GAAL,GAAW,SAASA,GAAT,CAAa3F,OAAb,EAAsBsE,EAAtB,EAA0B;AACjC,UAAM5C,GAAG,GAAGnC,IAAI,CAACE,OAAL,CAAaO,OAAb,EAAsBsE,EAAtB,CAAZ;AACA5C,IAAAA,GAAG,CAAC6B,GAAJ;AACA,WAAO7B,GAAP;AACH,GAJD;;AAMAhC,EAAAA,KAAK,CAACD,OAAN,GAAgB,UAAUO,OAAV,EAAmB0F,QAAnB,EAA6B;AACzC,QAAI,OAAO1F,OAAP,KAAmB,QAAvB,EAAiC;AAC7BA,MAAAA,OAAO,GAAGX,GAAG,CAACgB,KAAJ,CAAUL,OAAV,CAAV;AACH;;AACD,QAAI,CAACA,OAAO,CAACC,KAAb,EAAoB;AAChBD,MAAAA,OAAO,CAACC,KAAR,GAAgBuF,WAAhB;AACH;;AACD,WAAO7F,YAAY,CAACK,OAAD,EAAU0F,QAAV,CAAnB;AACH,GARD;;AASAhG,EAAAA,KAAK,CAACiG,GAAN,GAAY,SAASA,GAAT,CAAa3F,OAAb,EAAsBsE,EAAtB,EAA0B;AAClC,UAAM5C,GAAG,GAAGhC,KAAK,CAACD,OAAN,CAAcO,OAAd,EAAuBsE,EAAvB,CAAZ;AACA5C,IAAAA,GAAG,CAAC6B,GAAJ;AACA,WAAO7B,GAAP;AACH,GAJD;AAKH,CApCD","sourcesContent":["'use strict';\n\nvar url = require('url');\nvar http = require('http');\nvar httpRequest = http.request;\nvar https = require('https');\nvar httpsRequest = https.request;\nvar tls = require('tls');\nvar util = require('util');\nvar ntlm = require('./ntlm');\n\nfunction ProxyingAgent(options, agent) {\n  this.openSockets = {};\n  this.options = util._extend({}, options);\n  this.options.proxy = url.parse(this.options.proxy);\n  this.options.tunnel = this.options.tunnel || false;\n  this.options.ssl = this.options.proxy.protocol ? this.options.proxy.protocol.toLowerCase() == 'https:' : false;\n  this.options.host = this.options.proxy.hostname;\n  this.options.port = this.options.proxy.port || (this.options.ssl ? 443 : 80);\n  this.options.authType = this.options.authType || 'basic';\n\n  if (this.options.authType === 'ntlm') {\n    if (!this.options.proxy.auth) {\n      throw new Error('NTLM authentication credentials must be provided');\n    }\n    if (!this.options.ntlm || !this.options.ntlm.domain) {\n      throw new Error('NTLM domain must be provided');\n    }\n  }\n\n  // base64 decode proxy auth if necessary\n  var auth = this.options.proxy.auth;\n  if (auth && auth.indexOf(':') == -1) {\n    auth = new Buffer(auth, 'base64').toString('ascii');\n    // if after decoding there still isn't a colon, then revert back to the original value\n    if (auth.indexOf(':') == -1) {\n      auth = this.options.proxy.auth;\n    }\n    this.options.proxy.auth = auth;\n  }\n\n  // select the Agent type to use based on the proxy protocol\n  this.agent = agent;\n  this.agent.call(this, this.options);\n}\n\n/**\n * Get absolutURI without port when using default\n */\nProxyingAgent.prototype.getAbsoluteURI = function(ssl, host, port, path) {\n  var absoluteUri = (ssl ? 'https://' : 'http://') + host;\n\n  if (typeof port === 'string') {\n    // Check if target url have specified port and add it to absoluteUri\n    // When port is defined in target url then we get it as a string otherwise it's a number\n    absoluteUri += ':' + port;\n  }\n\n  absoluteUri += path;\n\n  return absoluteUri;\n};\n\n/**\n * Overrides the 'addRequest' Agent method for establishing a socket with the proxy\n * that will e used to issue the actual request\n */\nProxyingAgent.prototype.addRequest = function(req, host, port) {\n  if (typeof host === 'object') {\n    port = host.port;\n    host = host.hostname || host.host;\n  }\n  if (this.options.authType === 'ntlm') {\n    this.startNtlm(req, host, port);\n  } else {\n    this.startProxying(req, host, port);\n  }\n};\n\n/**\n * Start proxying the request through the proxy server.\n * This automatically opens a tunnel through the proxy if needed,\n * or just issues a regular request for the proxy to transfer\n */\nProxyingAgent.prototype.startProxying = function(req, host, port) {\n\n  // setup the basic authentication header for the proxy.\n  // we do this only if we haven't already authenticated through NTLM\n  if (this.options.authType == 'basic' && this.options.proxy.auth) {\n    this.authHeader = {\n      header: 'Proxy-Authorization',\n      value: 'Basic ' + new Buffer(this.options.proxy.auth).toString('base64')\n    }\n  }\n\n  // if we need to create a tunnel to the server via the CONNECT method\n  if (this.options.tunnel) {\n    var tunnelOptions = util._extend({}, this.options);\n    tunnelOptions.method = 'CONNECT';\n    tunnelOptions.path = host+':'+port;\n    tunnelOptions.hostname = this.options.proxy.hostname;\n    tunnelOptions.port = this.options.proxy.port;\n    tunnelOptions.headers = tunnelOptions.headers || {};\n\n    // if we already have a socket open then execute the CONNECT method on it\n    var socket = this.getSocket(req);\n    if (socket) {\n      tunnelOptions.agent = new SocketAgent(socket);\n    }\n\n    // add the authentication header\n    if (this.authHeader) {\n      tunnelOptions.headers[this.authHeader.header] = this.authHeader.value;\n      if (this.authHeader.keepAlive) {\n        tunnelOptions.headers[\"Proxy-Connection\"] = \"Keep-Alive\";\n      }\n    }\n\n    // create a new CONNECT request to the proxy to create the tunnel\n    // to the server\n    var newReq = this.createNewRequest(tunnelOptions);\n\n    newReq.once('close', function() {\n      this.emitError(req, 'Tunnel creation failed. Socket closed prematurely');\n    }.bind(this));\n\n    newReq.once('error', function(error) {\n      this.emitError(req, 'Tunnel creation failed. Socket error: ' + error);\n    }.bind(this));\n\n    // listen for the CONNECT event to complete and execute the original request\n    // on the TLSed socket\n    newReq.once('connect', function(response, socket, head) {\n      newReq.removeAllListeners();\n      if (response.statusCode != 200) {\n        this.emitError(req, 'Tunnel creation failed. Received status code ' + response.statusCode);\n        return;\n      }\n      var tlsOptions = this.options.tlsOptions || {};\n      tlsOptions.socket = response.socket;\n      tlsOptions.servername = host;\n\n      // upgrade the socket to TLS\n      var tlsSocket = tls.connect(tlsOptions, function() {\n        this.setSocket(req, tlsSocket);\n        this.execRequest(req, this.options.host, this.options.port);\n      }.bind(this));\n\n      tlsSocket.once('error', function(error) {\n        this.emitError(req, 'Tunnel socket error: ' + error);\n      }.bind(this));\n\n    }.bind(this));\n\n    // execute the CONNECT method to create the tunnel\n    newReq.end();\n  } else {\n    // issue a regular proxy request\n    req.path = this.getAbsoluteURI(this.options.ssl, host, port, req.path);\n    if (this.authHeader) {\n      req.setHeader(this.authHeader.header, this.authHeader.value);\n    }\n    this.execRequest(req, this.options.host, this.options.port);\n  }\n};\n\n/**\n * Start an NTLM authentication process. The result is an open socket that will be used\n * to issue the actual request or open a tunnel on\n */\nProxyingAgent.prototype.startNtlm = function(req, host, port) {\n  var ntlmOptions = util._extend({}, this.options);\n  ntlmOptions.method = ntlmOptions.method || 'GET'; // just for the NTLM handshake\n  ntlmOptions.path = this.getAbsoluteURI(this.options.ssl, host, port, req.path);\n  ntlmOptions.ntlm.workstation = ntlmOptions.ntlm.workstation || require('os').hostname();\n\n  var creds = this.options.proxy.auth.match(/([^:]*):?(.*)/);\n  ntlmOptions.ntlm.username = creds[1];\n  ntlmOptions.ntlm.password = creds[2];\n\n  // set the NTLM type 1 message header\n  ntlmOptions.headers = ntlmOptions.headers || {};\n  ntlmOptions.headers['Proxy-Authorization'] = ntlm.createType1Message(ntlmOptions.ntlm);\n  ntlmOptions.headers['Proxy-Connection'] = \"Keep-Alive\";\n\n  // create the NTLM type 1 request\n  var newReq = this.createNewRequest(ntlmOptions);\n\n  // capture the response and set the NTLM type 3 authorization header\n  // that will be used when issuing the actual request\n  newReq.once('response', function(response) {\n    if (response.statusCode !== 407 || !response.headers['proxy-authenticate']) {\n      this.emitError(req, 'did not receive NTLM type 2 message');\n      return;\n    }\n    var type2msg = ntlm.parseType2Message(response.headers['proxy-authenticate'], function(error) {\n      this.emitError(req, error);\n      return null;\n    }.bind(this));\n\n    if (!type2msg) {\n      return;\n    }\n\n    // capture the socket\n    this.setSocket(req, response.socket);\n\n    this.authHeader = {\n      header: 'Proxy-Authorization',\n      value: ntlm.createType3Message(type2msg, ntlmOptions.ntlm),\n      keepAlive: true\n    }\n\n    // read all the data from the socket as it may contain a body that should be discarded\n    response.on('data', function() {\n      // just consume the body\n    }.bind(this));\n\n    // start proxying\n    this.startProxying(req, host, port);\n\n  }.bind(this));\n\n  // start proxying the actual request only when there is not more body to read.\n  // the socket should have already been captured and associated with the request\n  newReq.once('close', function() {\n    this.emitError(req, 'NTLM failed. Socket closed prematurely');\n  }.bind(this));\n\n  newReq.once('error', function(error) {\n    this.emitError(req, 'NTLM failed. Socket error: ' + error);\n  }.bind(this));\n\n  // issue the NTLM type 1 request\n  newReq.end();\n};\n\n/**\n * Create a new request instance according the needed security\n */\nProxyingAgent.prototype.createNewRequest = function(options) {\n  if (options.ssl) {\n    return new httpsRequest(options);\n  }\n    return new httpRequest(options);\n};\n\n/**\n * Execute the provided request by invoking the original Agent 'addRequest' method.\n * If there is already a socket that was associated with the request, then it\n * will be used for issuing the request (via the 'createSocket' method)\n */\nProxyingAgent.prototype.execRequest = function(req, host, port) {\n  this.agent.prototype.addRequest.call(this, req, host, port);\n\n  // if there is an associated socket to this request then the association is removed\n  // since the socket was already passed to the request\n  if (this.openSockets[req]) {\n    delete this.openSockets[req];\n  }\n};\n\n/**\n * Remember a socket and associate it with a specific request.\n * When the 'createSocket' method will be called to execute the actual request\n * then the already existing socket will be used\n */\nProxyingAgent.prototype.setSocket = function(req, socket) {\n\n  this.openSockets[req] = socket;\n  var onClose = function() {\n    if (this.openSockets[req]) {\n      delete this.openSockets[req];\n    }\n  }.bind(this);\n  this.openSockets[req].on('close', onClose);\n};\n\nProxyingAgent.prototype.getSocket = function(req) {\n  return this.openSockets[req];\n};\n\n/**\n * This is called during the 'addRequest' call of the original Agent to return a\n * new socket for executing the request. If a socket already exists then it is used\n * instead of creating a new one.\n */\nProxyingAgent.prototype.createSocket = function() {\n\n  var req;\n  var cb;\n  if (typeof arguments[0] === 'object') {\n    req = arguments[0];\n    cb = arguments[2];\n  } else {\n    req = arguments[4];\n  }\n\n  if (this.openSockets[req]) {\n    if (cb) {\n      return cb(null, this.openSockets[req]);\n    } else {\n      return this.openSockets[req];\n    }\n  }\n  return this.agent.prototype.createSocket.apply(this, arguments);\n};\n\nProxyingAgent.prototype.emitError = function(req, message) {\n  (req.socket || req).emit('error', new Error(message));\n};\n\n\n//======= SocketAgent\n\n/**\n * A simple agent to execute a request on a given socket\n */\nfunction SocketAgent(socket) {\n  this.socket = socket;\n}\n\nSocketAgent.prototype.addRequest = function(req, host, port) {\n  req.onSocket(this.socket);\n};\n\n/**\n * HttpProxyingAgent\n * @param options\n * @constructor\n */\nfunction HttpProxyingAgent(options) {\n  ProxyingAgent.call(this, options, http.Agent);\n}\nutil.inherits(HttpProxyingAgent, http.Agent);\nutil._extend(HttpProxyingAgent.prototype, ProxyingAgent.prototype);\n\n/**\n * HttpsProxyingAgent\n * @param options\n * @constructor\n */\nfunction HttpsProxyingAgent(options) {\n  options.tunnel = true;\n  ProxyingAgent.call(this, options, https.Agent);\n}\nutil.inherits(HttpsProxyingAgent, https.Agent);\nutil._extend(HttpsProxyingAgent.prototype, ProxyingAgent.prototype);\n\n/**\n * Create the proxying agent\n * @param proxy\n * @param target\n * @returns {*}\n */\nexports.create = function(proxy, target) {\n  if (typeof proxy === 'string') {\n    proxy = {proxy: proxy}\n  }\n\n  if (target.toLowerCase().indexOf('https:') === 0) {\n    return new HttpsProxyingAgent(proxy);\n  }\n  return new HttpProxyingAgent(proxy);\n};\n\n/**\n * Set a global agent to forward all http and https requests through the specified proxy\n * @param proxy\n */\nexports.globalize = function (proxy) {\n    var copyProxy = JSON.parse(JSON.stringify(proxy));\n    var copySecureProxy = JSON.parse(JSON.stringify(proxy));\n    var secureAgent = this.create(copySecureProxy, 'https://');\n    var nonSecureAgent = this.create(copyProxy, 'http://');\n\n    http.request = function (options, callback) {\n        if (typeof options === 'string') {\n            options = url.parse(options);\n        }\n        if (!options.agent) {\n          options.agent = nonSecureAgent;\n        }\n        return httpRequest(options, callback);\n    };\n\n    http.get = function get(options, cb) {\n        const req = http.request(options, cb);\n        req.end();\n        return req;\n    };\n\n    https.request = function (options, callback) {\n        if (typeof options === 'string') {\n            options = url.parse(options);\n        }\n        if (!options.agent) {\n            options.agent = secureAgent;\n        }\n        return httpsRequest(options, callback);\n    };\n    https.get = function get(options, cb) {\n        const req = https.request(options, cb);\n        req.end();\n        return req;\n    };\n};\n"]},"metadata":{},"sourceType":"script"}